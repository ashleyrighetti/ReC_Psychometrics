#base_url = "spupsych.az1.qualtrics.com", overwrite = TRUE, install = TRUE)
surveys <- qualtRics::all_surveys()
View(surveys)
QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
View(QTRX_df)
#eliminating previews
QTRX_df <- dplyr::filter (QTRX_df, DistributionChannel != "preview")
QTRX_df <- dplyr::rename(QTRX_df, iRace1 = '1_iRace', iRace2 = '2_iRace', iRace3 = '3_iRace', iRace4 = '4_iRace', iRace5 = '5_iRace', iRace6 = '6_iRace', iRace7 = '7_iRace', iRace8 = '8_iRace', iRace9 = '9_iRace', iRace10 = '10_iRace')
QTRX_df <- dplyr::rename(QTRX_df, cmBiMulti = Race_10, cmBlack = Race_1, cmNBPoC = Race_7, cmWhite = Race_8, cmUnsure = Race_2)
QTRX_df <- QTRX_df %>% dplyr::mutate(ID = row_number())
QTRX_df <- QTRX_df%>%dplyr::select(ID, everything())
Model_df <-(select (QTRX_df, ID, iRace1, iRace2, iRace3, iRace4, iRace5, iRace6, iRace7, iRace8, iRace9, iRace10, cmBiMulti, cmBlack, cmNBPoC, cmWhite, cmUnsure, Blst_1:Blst_6, cEval_8, cEval_9, cEval_10, cEval_11, cEval_12, cEval_13, cEval_14, cEval_15, cEval_20, cEval_16,cEval_17))
View(Model_df)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
#saveRDS(Model_df, "Model_df.rds")
#bring back the simulated dat from an .rds file
Model_df <- readRDS("Model_df211010.rds") #For this lesson, I saved and imported this set of data; use it if you want the same results as are in the lesson and screencasted lecture
View(Model_df)
#str(Model_df$iRace1)
Model_df$tRace1 = factor(Model_df$iRace1,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace2 = factor(Model_df$iRace2,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace3 = factor(Model_df$iRace3,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace4 = factor(Model_df$iRace4,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace5 = factor(Model_df$iRace5,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace6 = factor(Model_df$iRace6,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace7 = factor(Model_df$iRace7,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace8 = factor(Model_df$iRace8,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace9 = factor(Model_df$iRace9,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace10 = factor(Model_df$iRace10,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
#checking to see that they are factors
#glimpse(Model_df)
#counting non-White instructional staff by creating the variable "count.BIPOC" by
#summing across tRace1 thru tRace10 and assigning a count of "1" each time the factor value was Black, nBpoc, or BiMulti
Model_df$count.BIPOC <- apply(Model_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(x %in% c("Black", "nBpoc", "BiMulti")))
#created a variable that counted the number of non-missing values across the tRace1 thru tRace10 vars
Model_df$count.nMiss <- apply(Model_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(!is.na(x)))
#calculate proportion of BIPOC instructional faculty for each case
Model_df$iBIPOC_pr = Model_df$count.BIPOC/Model_df$count.nMiss
Model_df<- Model_df %>%
dplyr::mutate(rBlst_1 = 8 - Blst_1) #if you had multiple items, you could add a pipe (%>%) at the end of the line and add more until the last one
#selecting the variables we want
Model_df <-(select (Model_df, ID, iBIPOC_pr, cmBlack, rBlst_1, Blst_2:Blst_6, cEval_8:cEval_17))
cases1 <- nrow(Model_df) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
cases1
Model_df$n_miss <- Model_df%>%
select(iBIPOC_pr:cEval_17) %>%
is.na %>%
rowSums
Model_df<- Model_df%>%
mutate(prop_miss = (n_miss/21)*100)%>%
arrange(desc(n_miss))
PrMiss1 <- psych::describe(Model_df$prop_miss)
PrMiss1
CellsMissing1 <-formattable::percent(mean(is.na(Model_df))) #percent missing across df
cases1 <- nrow(Model_df) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
cases1
library(tidyverse)
#Create a variable (n_miss) that counts the number missing
Model_df$n_miss <- Model_df%>%
select(iBIPOC_pr:cEval_17) %>%
is.na %>%
rowSums
#Create a proportion missing by dividing n_miss by the total number of variables (21)
#Sort in order of descending frequency to get a sense of the missingness
Model_df<- Model_df%>%
mutate(prop_miss = (n_miss/21)*100)%>%
arrange(desc(n_miss))
PrMiss1 <- psych::describe(Model_df$prop_miss)
PrMiss1
MissMin1 <- formattable::digits(PrMiss1$min, 0)#this object is displayed below and I use input from  it for the inline text used in the write-up
MissMax1 <- formattable::digits(PrMiss1$max, 0)
MissMin1
MissMax1
CellsMissing1 <-formattable::percent(mean(is.na(Model_df))) #percent missing across df
RowsMissing1 <- formattable::percent(mean(complete.cases(Model_df))) #percent of rows with nonmissing data
CellsMissing1
RowsMissing1
CellsMissing1
CellsMissing1
RowsMissing1
missingness <- mice::md.pattern(Model_df, plot = TRUE, rotate.names=TRUE)
missingness
Model_df <- filter(Model_df, prop_miss <= 20)  #update df to have only those with at least 20% of complete data (this is an arbitrary decision)
Model_df <-(select (Model_df, iBIPOC_pr:cEval_17)) #the variable selection just lops off the proportion missing
Model_df <- filter(Model_df, prop_miss <= 20)  #update df to have only those with at least 20% of complete data (this is an arbitrary decision)
CasesIncluded <- nrow(Model_df)
CasesIncluded
CellsMissing2 <- formattable::percent(mean(is.na(Model_df))) #percent missing across df
RowsMissing2 <- formattable::percent(mean(complete.cases(Model_df))) #percent of rows with nonmissing data
CellsMissing2
RowsMissing2
missingness2 <- mice::md.pattern(Model_df, plot = TRUE, rotate.names=TRUE)
missingness2
psych::describe(Model_df)
Model_df$Mahal <- psych::outlier(Model_df)
Model_df$Mahal <- psych::outlier(Model_df)
library(dplyr)
#str(item_scores_df$Mahal)
Model_df$MOutlier <- if_else(Model_df$Mahal > (median(Model_df$Mahal) + (3*sd(Model_df$Mahal))), TRUE, FALSE)
OutlierCount <- Model_df%>%
count(MOutlier)
OutlierCount
NumOutliers <- nrow(Model_df) - OutlierCount #calculating how many outliers
NumOutliers #this object is used for the inline text for the reesults
NumOutliers
head(Model_df) #shows us the first 6 rows of the data so we can see the new variables (Mahal, MOutlier)
OutlierCount
ClimateItems <- dplyr::select(Model_df, rBlst_1, Blst_2, Blst_3, Blst_4, Blst_5, Blst_6)
CEvalItems <- dplyr::select(Model_df, cEval_8, cEval_9, cEval_10, cEval_11, cEval_12, cEval_13, cEval_14, cEval_15, cEval_16, cEval_17, cEval_20)
View(CEvalItems)
ClimateAlpha <- psych::alpha(ClimateItems)
ClimateAlpha
ClimateItems <- dplyr::select(Model_df, rBlst_1, Blst_2, Blst_3, Blst_4, Blst_5, Blst_6)
CEvalItems <- dplyr::select(Model_df, cEval_8, cEval_9, cEval_10, cEval_11, cEval_12, cEval_13, cEval_14, cEval_15, cEval_16, cEval_17, cEval_20)
View(CEvalItems)
View(ClimateAlpha)
View(ClimateAlpha)
View(ClimateItems)
ClimateAlpha <- psych::alpha(ClimateItems)
ClimateAlpha
ClimAlpha <- formattable::digits(ClimateAlpha$total$std.alpha,3)
ClimAlpha
CEvalAlpha <- psych::alpha(CEvalItems)
CEvalAlpha
EvalAlpha <- formattable::digits(CEvalAlpha$total$std.alpha,3)
EvalAlpha
#create lists of the items
ClimateVars <- c('rBlst_1', 'Blst_2', 'Blst_3', 'Blst_4', 'Blst_5', 'Blst_6')
CEvalVars <- c('cEval_8', 'cEval_9', 'cEval_10', 'cEval_11', 'cEval_12', 'cEval_13', 'cEval_14', 'cEval_15', 'cEval_16', 'cEval_17', 'cEval_20')
#calculate means for when a specified proportion of items are non-missing
Model_df$ClimateM <- sjstats::mean_n(Model_df[,ClimateVars], .80)#will create the mean for each individual if 80% of variables are present (this means there must be at least 5 of 6)
Model_df$CEvalM <- sjstats::mean_n(Model_df[,CEvalVars], .80)#will create the mean for each individual if 80% of variables are present (this means there must be at least 9 of 11)
apaTables::apa.cor.table(Model_df[c('ClimateM', 'CEvalM', 'iBIPOC_pr', 'cmBlack')], landscape=TRUE, table.number = 1, filename="Table1_Prelim.doc")
msmt <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ cEval_8 + cEval_9 + cEval_10 + cEval_11 + cEval_12 + cEval_13 + cEval_14 + cEval_15 + cEval_20 + cEval_16 + cEval_17
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
'
msmt_fit <- lavaan::cfa(msmt, data = Model_df, missing = "fiml", check.gradient=FALSE)
#msmt_fit <- lavaan::cfa(msmt, data = Model_df,  missing = "fiml", estimator = "ML", bounds = "wide")
m1fitsum <- lavaan::summary(msmt_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
#missing = 'fiml',
names(m1fitsum$FIT)
chi2_m1 <- formattable::digits(m1fitsum$FI[3], 3)
chi2_m1
chi2df_m1 <- formattable::digits(m1fitsum$FI[4], 3)
chi2df_m1
chi2p_m1 <- formattable::digits(m1fitsum$FI[5], 3)
chi2p_m1
cfi_m1 <- formattable::digits(m1fitsum$FI[9], 3)
cfi_m1
rmsea_m1 <- formattable::digits(m1fitsum$FI[17], 3)
rmsea_m1
rmseaLO_m1 <- formattable::digits(m1fitsum$FI[18], 3)
rmseaLO_m1
rmseaHI_m1 <- formattable::digits(m1fitsum$FI[19], 3)
rmseaHI_m1
srmr_m1 <- formattable::digits(m1fitsum$FI[21], 3)
srmr_m1
plot_m1 <- semPlot::semPaths(msmt_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m1_msmt <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(2,1),
CrE = c(1,2),
Clm = c(2,2))
#m_msmt #can check to see if it is what you thought you did
#tell where you want the indicators to face
m1_point_to <- semptools::layout_matrix (left = c(1,1),
left = c(2,1),
up = c(1,2),
down = c(2,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m1_indicator_order <- c("cmB",
"iBI",
"cE_8","cE_9","cE_10","cE_11","cE_12","cE_13","cE_14","cE_15","cE_2","cE_16","cE_17",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
m1_indicator_factor <- c("sBl",
"tBI",
"CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
m1_indicator_push <- c(sBl = 2.5, #pushing the 1-item indicators only a little way away
tBI = 2.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
m1_indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
msmtplot1 <- semptools::set_sem_layout(plot_m1,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(msmtplot1)
#changing node labels
msmtplot1b <- semptools::change_node_label(msmtplot1,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(msmtplot1b)
set.seed(211106)
items <- c("cEval_8", "cEval_9", "cEval_10", "cEval_11", "cEval_12", "cEval_13", "cEval_14", "cEval_15", "cEval_20", "cEval_16", "cEval_17")
parcels <- c("parcel_1", "parcel_2","parcel_3")
data.frame(items = sample(items),
parcel = rep(parcels, length = length(items)))
parcel1_vars <- c('cEval_15', 'cEval_16', 'cEval_12','cEval_17')
parcel2_vars <- c('cEval_20', 'cEval_13', 'cEval_9','cEval_14')
parcel3_vars <- c('cEval_10', 'cEval_8', 'cEval_11')
Model_df$EvalP1 <- sjstats::mean_n(Model_df[,parcel1_vars], .80)
Model_df$EvalP2 <- sjstats::mean_n(Model_df[,parcel2_vars], .80)
Model_df$EvalP3 <- sjstats::mean_n(Model_df[,parcel3_vars], .80)
View(Model_df)
msmt_parceled <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ EvalP1 + EvalP2 + EvalP3
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
'
msmtP_fit <- lavaan::cfa(msmt_parceled, data = Model_df, missing = "fiml", check.gradient=FALSE)
#msmt_fit <- lavaan::cfa(msmt, data = Model_df,  missing = "fiml", estimator = "ML", bounds = "wide")
m2fitsum <-lavaan::summary(msmtP_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
#missing = 'fiml',
chi2_m2 <- formattable::digits(m2fitsum$FI[3], 3)
chi2_m2
chi2df_m2 <- formattable::digits(m2fitsum$FI[4], 3)
chi2df_m2
chi2p_m2 <- formattable::digits(m2fitsum$FI[5], 3)
chi2p_m2
cfi_m2 <- formattable::digits(m2fitsum$FI[9], 3)
cfi_m2
rmsea_m2 <- formattable::digits(m2fitsum$FI[17], 3)
rmsea_m2
rmseaLO_m2 <- formattable::digits(m2fitsum$FI[18], 3)
rmseaLO_m2
rmseaHI_m2 <- formattable::digits(m2fitsum$FI[19], 3)
rmseaHI_m2
srmr_m2 <- formattable::digits(m2fitsum$FI[21], 3)
srmr_m2
vbls <- c(rBlst_1 = "My university provides a supportive environment for Black students", Blst_4 = "My university is unresponsive to the needs of Black students", Blst_6  = "My university is cold and uncaring toward Black students and race-related issues", Blst_2 = "Anti-Black racism is visible in my campus", Blst_3 = "Negative attitudes toward persons who are Black are openly expressed in my university", Blst_5  = "Students who are Black are harassed in my university", iBIPOC_pr = "Proportion of Instructors who are BIPOC", cmBlack = "Proportion of Classmates who are Black")
Table <- semTable::semTable(msmt_fit, columnLabels = c(eststars = "Estimate", se = "SE", p = "p-value"), fits = c("chisq", "df", "pvalue", "cfi", "rmsea", "rmsea.ci.lower", "rmsea.ci.upper", "srmr", "aic", "bic"), varLabels = vbls, file = "msmt_fit", type = "csv", print.results = TRUE)
plot_m1 <- semPlot::semPaths(msmt_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
msmtplot <- semPlot::semPaths(msmtP_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m_msmt <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(2,1),
CrE = c(1,2),
Clm = c(2,2))
#m_msmt #can check to see if it is what you thought you did
#tell where you want the indicators to face
M_point_to <- semptools::layout_matrix (left = c(1,1),
left = c(2,1),
up = c(1,2),
down = c(2,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
M_indicator_order <- c("cmB",
"iBI",
"EP1", "EP2", "EP3",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
M_indicator_factor <- c("sBl",
"tBI",
"CrE", "CrE", "CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
M_indicator_push <- c(sBl = 2.5, #pushing the 1-item indicators only a little way away
tBI = 2.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
M_indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
msmtplot2 <- semptools::set_sem_layout(msmtplot,
indicator_order = M_indicator_order,
indicator_factor = M_indicator_factor,
factor_layout = m_msmt,
factor_point_to = M_point_to,
indicator_push = M_indicator_push,
indicator_spread = M_indicator_spread)
plot(msmtplot2)
#changing node labels
msmtplot2b <- semptools::change_node_label(msmtplot2,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(msmtplot2b)
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m_msmt <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(2,1),
CrE = c(1,2),
Clm = c(2,2))
#m_msmt #can check to see if it is what you thought you did
#tell where you want the indicators to face
M_point_to <- semptools::layout_matrix (left = c(1,1),
left = c(2,1),
up = c(1,2),
down = c(2,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
M_indicator_order <- c("cmB",
"iBI",
"EP1", "EP2", "EP3",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
M_indicator_factor <- c("sBl",
"tBI",
"CrE", "CrE", "CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
M_indicator_push <- c(sBl = 2.5, #pushing the 1-item indicators only a little way away
tBI = 2.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
M_indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
msmtplot2 <- semptools::set_sem_layout(msmtplot,
indicator_order = M_indicator_order,
indicator_factor = M_indicator_factor,
factor_layout = m_msmt,
factor_point_to = M_point_to,
indicator_push = M_indicator_push,
indicator_spread = M_indicator_spread)
plot(msmtplot2)
#changing node labels
msmtplot2b <- semptools::change_node_label(msmtplot2,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(msmtplot2b)
struct1 <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ EvalP1 + EvalP2 + EvalP3
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
#structural paths
Climate ~ b*CourseEval + c_p1*tBIPOC + c_p2*sBlack
CourseEval ~ a1*tBIPOC + a2*sBlack
#script that produces information about indirect, direct, and total effects
indirect1 := a1 * b
indirect2 := a2 * b
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p1 + c_p2 + (indirect1) + (indirect2)
direct1 := c_p1
direct2 := c_p2
'
#note change in script from cfa to sem
struct1_fit <- lavaan::sem(struct1, data = Model_df, missing = 'fiml', orthogonal = TRUE)
s1fitsum<-lavaan::summary(struct1_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
chi2_s2 <- formattable::digits(s1fitsum$FI[3], 3)
chi2_s2
chi2df_s2 <- formattable::digits(s1fitsum$FI[4], 3)
chi2df_s2
chi2p_s2 <- formattable::digits(s1fitsum$FI[5], 3)
chi2p_s2
cfi_s2 <- formattable::digits(s1fitsum$FI[9], 3)
cfi_s2
rmsea_s2 <- formattable::digits(s1fitsum$FI[17], 3)
rmsea_s2
rmseaLO_s2 <- formattable::digits(s1fitsum$FI[18], 3)
rmseaLO_s2
rmseaHI_s2 <- formattable::digits(s1fitsum$FI[19], 3)
rmseaHI_s2
srmr_s2 <- formattable::digits(s1fitsum$FI[21], 3)
srmr_s2
b_B <- formattable::digits(s1fitsum$PE$est[14], 3) #B weight for the b path
b_B
b_se <- formattable::digits(s1fitsum$PE$se[14], 3) #B weight for the b path
b_se
b_p <- formattable::digits(s1fitsum$PE$pvalue[14], 3) #B weight for the b path
b_p
a1_B <- formattable::digits(s1fitsum$PE$est[17], 3) #B weight for the b path
a1_B
a1_se <- formattable::digits(s1fitsum$PE$se[17], 3) #B weight for the b path
a1_se
a1_p <- formattable::digits(s1fitsum$PE$pvalue[17], 3) #B weight for the b path
a1_p
a2_B <- formattable::digits(s1fitsum$PE$est[18], 3) #B weight for the b path
a2_B
a2_se <- formattable::digits(s1fitsum$PE$se[18], 3) #B weight for the b path
a2_se
a2_p <- formattable::digits(s1fitsum$PE$pvalue[18], 3) #B weight for the b path
a2_p
cp1_B <- formattable::digits(s1fitsum$PE$est[15], 3) #B weight for the b path
cp1_B
cp1_se <- formattable::digits(s1fitsum$PE$se[15], 3) #B weight for the b path
cp1_se
cp1_p <- formattable::digits(s1fitsum$PE$pvalue[15], 3) #B weight for the b path
cp1_p
cp2_B <- formattable::digits(s1fitsum$PE$est[16], 3) #B weight for the b path
cp2_B
cp2_se <- formattable::digits(s1fitsum$PE$se[16], 3) #B weight for the b path
cp2_se
cp2_p <- formattable::digits(s1fitsum$PE$pvalue[16], 3) #B weight for the b path
cp2_p
ind1_B <- formattable::digits(s1fitsum$PE$est[48], 3) #B weight for the b path
ind1_B
ind1_se <- formattable::digits(s1fitsum$PE$se[48], 3) #B weight for the b path
ind1_se
ind1_p <- formattable::digits(s1fitsum$PE$pvalue[48], 3) #B weight for the b path
ind1_p
ind2_B <- formattable::digits(s1fitsum$PE$est[49], 3) #B weight for the b path
ind2_B
ind2_se <- formattable::digits(s1fitsum$PE$se[49], 3) #B weight for the b path
ind2_se
ind2_p <- formattable::digits(s1fitsum$PE$pvalue[49], 3) #B weight for the b path
ind2_p
dir1_B <- formattable::digits(s1fitsum$PE$est[53], 3) #B weight for the b path
dir1_B
dir1_se <- formattable::digits(s1fitsum$PE$se[53], 3) #B weight for the b path
dir1_se
dir1_p <- formattable::digits(s1fitsum$PE$pvalue[53], 3) #B weight for the b path
dir1_p
dir2_B <- formattable::digits(s1fitsum$PE$est[54], 3) #B weight for the b path
dir2_B
dir2_se <- formattable::digits(s1fitsum$PE$se[54], 3) #B weight for the b path
dir2_se
dir2_p <- formattable::digits(s1fitsum$PE$pvalue[54], 3) #B weight for the b path
dir2_p
indT_B <- formattable::digits(s1fitsum$PE$est[51], 3) #B weight for the b path
indT_B
indT_se <- formattable::digits(s1fitsum$PE$se[51], 3) #B weight for the b path
indT_se
indT_p <- formattable::digits(s1fitsum$PE$pvalue[51], 3) #B weight for the b path
indT_p
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#I used this code to get a plot without the results printed on the paths
#p <- semPlot::semPaths (struct1_fit, what = "mod", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m_sem <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(3,1),
CrE = c(2,2),
Clm = c(2,3))
#m_sem #check to see if they are where you thougth they would be; NA will be used as placeholders
#tell where you want the indicators to face
point_to <- semptools::layout_matrix (left = c(1,1),
left = c(3,1),
down = c(2,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
indicator_order <- c("cmB",
"iBI",
"EP1", "EP2", "EP3",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
indicator_factor <- c("sBl",
"tBI",
"CrE", "CrE", "CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
indicator_push <- c(sBl = 1.5, #pushing the 1-item indicators only a little way away
tBI = 1.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
p2 <- semptools::set_sem_layout(p,
indicator_order = indicator_order,
indicator_factor = indicator_factor,
factor_layout = m_sem,
factor_point_to = point_to,
indicator_push = indicator_push,
indicator_spread = indicator_spread)
plot(p2)
#changing node labels
p3 <- semptools::change_node_label(p2,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(p3)
vbls <- c(rBlst_1 = "My university provides a supportive environment for Black students", Blst_4 = "My university is unresponsive to the needs of Black students", Blst_6  = "My university is cold and uncaring toward Black students and race-related issues", Blst_2 = "Anti-Black racism is visible in my campus", Blst_3 = "Negative attitudes toward persons who are Black are openly expressed in my university", Blst_5  = "Students who are Black are harassed in my university", iBIPOC_pr = "Proportion of Instructors who are BIPOC", cmBlack = "Proportion of Classmates who are Black")
Table <- semTable::semTable(msmt_fit, columnLabels = c(eststars = "Estimate", se = "SE", p = "p-value"), fits = c("chisq", "df", "pvalue", "cfi", "rmsea", "rmsea.ci.lower", "rmsea.ci.upper", "srmr", "aic", "bic"), varLabels = vbls, file = "msmt_fit", type = "csv", print.results = TRUE)
